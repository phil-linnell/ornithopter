/**
 * CSS Animation function v.0.1.1
 * by Phil Linnell, phil@ustwo.com
 *
 * A function that compiles a series of animation segments declared in an object
 * (durations in seconds) to a set of keyframes which allows for cubic-bezier motion
 * within each animation segment, e.g. cubic-bezier(.6, .1, .2, .8) from 20% to 50%.
 *
*/

animate(a) {

  @keyframes {a.name} {

     for type, i in a.animations {

      $prop = a.animations[type].property.prop;
      $duration = a.animations[type].duration;
      $delay = a.animations[type].delay;
      $accuracy = a.animations[type].accuracy;
      $from = a.animations[type].from;
      $to = a.animations[type].to;
      $total = $duration + $delay;

      $per-delay = $delay / a.total-duration * 100%;
      $per-duration = $duration / a.total-duration * 100%;

      if ($prop == transform) {
        $transform-type = a.animations[type].property.type;
        $from = $transform-type + "(" + $from + ")";
        $to = $transform-type + "(" + $to + ")";
      }

      // Start all animations
      if ($delay > 0) {
        {round($per-delay)} {
          {$prop}: $from;
        }
      } else {
        0% {
          {$prop}: $from;
        }
      }

      // Animations' keyframes
      if (a.animations[type].curves) {
        for i in ($accuracy)..1 {
          // Return sets of coordinates between 0 and 1 equal to animation's accuracy
          t = i * (1 / ($accuracy + 1));
          d = 1

          b0 = t * t * t
          b1 = 3 * t * t * (1 - t)
          b2 = 3 * t * (1 - t) * (1 - t)
          b3 = (1 - t) * (1 - t) * (1 - t)

          p0 = 0 0;
          p1x = a.animations[type].curves.c1[0];
          p1y = a.animations[type].curves.c1[1];
          p2x = a.animations[type].curves.c2[0];
          p2y = a.animations[type].curves.c2[1];
          p3 = 1 1;

          x = p0[0] * (b0 * d) + p1x * (b1 * d) + p2x * (b2 * d) + p3[0] * (b3 * d);
          y = p0[1] * (b0 * d) + p1y * (b1 * d) + p2y * (b2 * d) + p3[1] * (b3 * d);

          {round(($per-delay) + (x * $per-duration))} {

            if ($prop == transform) {
              $to2 = a.animations[type].to; // Need this as $to already overriden in if(transform) above
              $from2 = a.animations[type].from;
              $new-to = $transform-type + "(" + round($to2 * y) + ")";
              $new-from = $transform-type + "(" + round($from2 - ($from2 * y)) + ")";
              if ($to > $from) {
                {$prop}: $new-to;
              } else {
                {$prop}: $new-from;
              }
            } else {
              $new-to = round($to * y);
              $new-from = round($from * y);
              if ($to > $from) {
                {$prop}: $new-to;
              } else {
                {$prop}: $from - $new-from;
              }
            }

          }

        }
      }


      // End all animations
      {round($total / a.total-duration * 100%)} {
        {$prop}: $to;
      }

      // Preserve end state of any animations to 100%
      // if ((a.animations[type].duration + $delay) < a.total-duration) {
      //   100% {
      //     {$prop}: $to;
      //   }
      // }

    }

  }

  animation: unquote(a.name + " " + a.total-duration + "s " + a.iteration + " " + a.curves);

}






/** Example
*/



loader-size = 12px;
loader-jump = loader-size * 2.25;
loader-bg = #fff;

$jumping-box = {
  name: jumping,
  total-duration: 1.7,
  iteration: infinite,
  curves: linear,
  animations: {
    moveUp: {
      property: {
        prop: bottom,
      }
      from: 0,
      to: loader-jump,
      duration: 0.5,
      delay: 0.33,
      curves: {
        c1: 0 1,
        c2: 0.86 1
      },
      accuracy: 5
    }
    moveDown: {
      property: {
        prop: bottom,
      }
      from: loader-jump,
      to: 0,
      duration: 0.33,
      delay: 0.83,
      curves: {
        c1: 0.5 0,
        c2: 1 0.8
      },
      accuracy: 5
    }
    squashDown: {
      property: {
        prop: transform,
        type: scale
      }
      from: '1, 1',
      to: '1.25, 0.25',
      duration: 0.33,
      delay: 0
    }
    squashUp: {
      property: {
        prop: transform,
        type: scale
      }
      from: '1.25, 0.25',
      to: '0.8, 1.13',
      duration: 0.25,
      delay: 0.33
    }
    squashNormalise: {
      property: {
        prop: transform,
        type: scale
      }
      from: '0.8, 1.13',
      to: '1, 1',
      duration: 0.33,
      delay: 0.58
    }
    squashTop: {
      property: {
        prop: transform,
        type: scale
      }
      from: '1, 1',
      to: '1, 0.8',
      duration: 0.25,
      delay: 0.91
    }
    squashFall: {
      property: {
        prop: transform,
        type: scale
      }
      from: '1, 0.8',
      to: '1.5, 0.25',
      duration: 0.08,
      delay: 1.16
    }
    squashEnd: {
      property: {
        prop: transform,
        type: scale
      }
      from: '1.5, 0.25',
      to: '1, 1',
      duration: 0.25,
      delay: 1.24
    }
  }
}

* {
  padding: 0;
  margin: 0;
}

.loading {
  display: flex;
  flex: 1;
  align-items: center;
  justify-content: center;
  height: calc(100vh - 80px);

  ul {
    margin-bottom: 70px;
    font-size: 0;

    li {
      position: relative;
      width: loader-size;
      height: loader-size + loader-jump;
      display: inline-block;
      margin-left: loader-size * .75;

      &:first-child {
        margin-left: 0;
      }

      div {
        position: absolute;
        bottom: 0;
        left: 0;
        width: loader-size;
        height: loader-size;
        background: #FFBF02;
        animate($jumping-box);
        transform-origin: 50% bottom;
      }

      &:nth-child(2) div {
        animation-delay: 0.08s;
        background: #96CC29;
      }
      &:nth-child(3) div {
        animation-delay: 0.16s;
        background: #009CF3;
      }
      &:nth-child(4) div {
        animation-delay: 0.24s;
        background: #ED0082;
      }
    }
  }
}
