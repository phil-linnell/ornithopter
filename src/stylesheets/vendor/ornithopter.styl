/**
 * CSS Animation function v.0.1
 * by Phil Linnell, phil@ustwo.com
 *
 * Create a series of CSS only animations allowing for cubic-bezier motion
 * within in each animation segment, e.g. 10% - 20%.
 * Duration values in seconds(s)
 *
*/

animate(a) {

  @keyframes {a.name} {

     for type, i in a.animations {

      $prop = a.animations[type].property.prop;
      $duration = a.animations[type].duration;
      $delay = a.animations[type].delay;
      $accuracy = a.animations[type].accuracy;
      $from = a.animations[type].from;
      $to = a.animations[type].to;
      $total = $duration + $delay;

      $per-delay = $delay / a.total-duration * 100%;
      $per-duration = $duration / a.total-duration * 100%;

      if ($prop == transform) {
        $transform-type = a.animations[type].property.type;
        if (a.animations[type].property.option) {
          $transform-type-option = a.animations[type].property.option;
        }
        $from = $transform-type + $transform-type-option + "(" + $from + ")";
        $to = $transform-type + $transform-type-option + "(" + $to + ")";
      }

      // Start all animations
      if ($delay > 0) {
        {round($per-delay)} {
          {$prop}: $from;
        }
      } else {
        0% {
          {$prop}: $from;
        }
      }

      // Animations' keyframes
      if (a.animations[type].curves) {
        for i in ($accuracy)..1 {
          // Return sets of coordinates between 0 and 1 equal to animation's accuracy
          t = i * (1 / ($accuracy + 1));
          d = 1

          b0 = t * t * t
          b1 = 3 * t * t * (1 - t)
          b2 = 3 * t * (1 - t) * (1 - t)
          b3 = (1 - t) * (1 - t) * (1 - t)

          p0 = {
            x: 0,
            y: 0
          }
          p1 = {
            x: a.animations[type].curves.p1.x,
            y: a.animations[type].curves.p1.y
          }
          p2 = {
            x: a.animations[type].curves.p2.x,
            y: a.animations[type].curves.p2.y
          }
          p3 = {
            x: 1,
            y: 1
          }

          x = p0.x * (b0 * d) + p1.x * (b1 * d) + p2.x * (b2 * d) + p3.x * (b3 * d);
          y = p0.y * (b0 * d) + p1.y * (b1 * d) + p2.y * (b2 * d) + p3.y * (b3 * d);

          {round(($per-delay) + (x * $per-duration))} {

            if ($prop == transform) {
              $to2 = a.animations[type].to; // Need this as $to already overriden in if(transform) above
              $from2 = a.animations[type].from;
              $new-to = $transform-type + $transform-type-option + "(" + round($to2 * y) + ")";
              $new-from = $transform-type + $transform-type-option + "(" + round($from2 - ($from2 * y)) + ")";
              if ($to > $from) {
                {$prop}: $new-to;
              } else {
                {$prop}: $new-from;
              }
            } else {
              $new-to = round($to * y);
              $new-from = round($from * y);
              if ($to > $from) {
                {$prop}: $new-to;
              } else {
                {$prop}: $from - $new-from;
              }
            }

          }

        }
      }


      // End all animations
      {round($total / a.total-duration * 100%)} {
        {$prop}: $to;
      }

      // Preserve end state of any animations to 100%
      // if ((a.animations[type].duration + $delay) < a.total-duration) {
      //   100% {
      //     {$prop}: $to;
      //   }
      // }

    }

  }

  animation: unquote(a.name + " " + a.total-duration + "s " + a.iteration + " " + a.curves);

}







/** Example
*/



$block-animation = {
  name: block-move,
  total-duration: 3,
  iteration: infinite,
  curves: linear,
  animations: {
    color: {
      property: {
        prop: background-color,
      }
      from: red,
      to: green,
      duration: 1.5,
      delay: 0
    }
    move: {
      property: {
        prop: transform,
        type: translate,
        option: Y
      }
      from: 200px,
      to: 0,
      duration: 1,
      delay: 0,
      curves: {
        p1: {
          x: .62,
          y: .1
        }
        p2: {
          x: .26,
          y: .86
        }
      },
      accuracy: 10
    },
    spin: {
      property: {
        prop: transform,
        type: rotate,
        option: Z
      }
      from: 0,
      to: 360deg,
      duration: 1,
      delay: 1,
      curves: {
        p1: {
          x: .3,
          y: 0
        }
        p2: {
          x: 0,
          y: 1
        }
      },
      accuracy: 10
    },
    move-back: {
      property: {
        prop: transform,
        type: translate,
        option: Y
      }
      from: 0,
      to: 200px,
      duration: 1,
      delay: 2,
      curves: {
        p1: {
          x: .3,
          y: 0
        }
        p2: {
          x: 0,
          y: 1
        }
      },
      accuracy: 10
    }
  }
}


.block {
  animate($block-animation);
  width: 40px;
  height: @width;
  background: red;
  transform: translateY(200px);
}
