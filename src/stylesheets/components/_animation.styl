/**
 * CSS Animation function
 *
 * Duration values in seconds(s)
 *
 *
 *
*/
//
//
// cubicbezier(s, p1x, p1y, p2x, p2y) {
//   for i in (s)..1 {
//     t = i * (1 / (s + 1));
//     d = 1
//
//     b0 = t * t * t
//     b1 = 3 * t * t * (1 - t)
//     b2 = 3 * t * (1 - t) * (1 - t)
//     b3 = (1 - t) * (1 - t) * (1 - t)
//
//     p0 = {
//       x: 0,
//       y: 0
//     }
//     p1 = {
//       x: p1x,
//       y: p1y
//     }
//     p2 = {
//       x: p2x,
//       y: p2y
//     }
//     p3 = {
//       x: 1,
//       y: 1
//     }
//
//     x = p0.x * (b0 * d) + p1.x * (b1 * d) + p2.x * (b2 * d) + p3.x * (b3 * d);
//     y = p0.y * (b0 * d) + p1.y * (b1 * d) + p2.y * (b2 * d) + p3.y * (b3 * d);
//
//     x: x;
//     y: y;
//
//   }
// }
//
// cubicbezier(4,0,0.5,0.5,1);

animate(core, animations) {

  @keyframes {core.name} {

     for type, i in animations {

      $p = animations[type].property;
      $duration = animations[type].duration;
      $delay = animations[type].delay;
      $accuracy = animations[type].accuracy;

      // Start all animations
      if (animations[type].delay > 0) {
        {animations[type].delay / core.total-duration * 100%} {
          $p: animations[type].from;
        }
      } else {
        0% {
          $p: animations[type].from;
        }
      }

      // Animations' keyframes
      if (animations[type].curves) {
        for i in (4)..1 {
          // Return 4 sets of coordinates between 0 and 1
          // so, 20%, 40%, 60% and 80%
          t = i * (1 / (4 + 1));
          d = 1

          b0 = t * t * t
          b1 = 3 * t * t * (1 - t)
          b2 = 3 * t * (1 - t) * (1 - t)
          b3 = (1 - t) * (1 - t) * (1 - t)

          p0 = {
            x: 0,
            y: 0
          }
          p1 = {
            x: animations[type].curves.p1x,
            y: animations[type].curves.p1y
          }
          p2 = {
            x: animations[type].curves.p2x,
            y: animations[type].curves.p2y
          }
          p3 = {
            x: 1,
            y: 1
          }

          x = p0.x * (b0 * d) + p1.x * (b1 * d) + p2.x * (b2 * d) + p3.x * (b3 * d);
          y = p0.y * (b0 * d) + p1.y * (b1 * d) + p2.y * (b2 * d) + p3.y * (b3 * d);

          {(x * 100%) + animations[type].delay / core.total-duration * 100%} {
            $p: unquote("translateY(" + y * 100px + ")");
          }

        }
      }


      // End all animations
      {animations[type].total / core.total-duration * 100%} {
        $p: animations[type].to;
      }

      // Preserve end state of any animations to 100%
      if (animations[type].duration < core.total-duration) {
        100% {
          $p: animations[type].to;
        }
      }

    }

  }

  animation: unquote(core.name + " " + core.total-duration + "s " + core.iteration + " " + core.curves);

}







/** Example
*/



$block-core = {
  name: block-move,
  total-duration: 2,
  iteration: infinite,
  curves: linear
}

$block-animations = {
  move: {
    property: transform,
    attribute: translateY,
    from: translateY(0px),
    to: translateY(100px),
    duration: 1.5,
    delay: 0.5,
    total: 2, // TODO: remove the need for this
    curves: {
      p1x: 0,
      p1y: 0,
      p2x: 0,
      p2y: 1
    },
    accuracy: 5
  },
  fade: {
    property: opacity,
    from: 0,
    to: 1,
    duration: 0.5,
    delay: 0,
    total: 0.5
  }
}


.block {
  animate($block-core, $block-animations);
  width: 40px;
  height: @width;
  background: #000;
}
