/**
 * CSS Animation function
 *
 * Duration values in seconds(s)
 *
 *
 *
*/
//
//
cubicbezier(s, p1x, p1y, p2x, p2y) {
  for i in (s)..1 {
    t = i * (1 / (s + 1));
    d = 1

    b0 = t * t * t
    b1 = 3 * t * t * (1 - t)
    b2 = 3 * t * (1 - t) * (1 - t)
    b3 = (1 - t) * (1 - t) * (1 - t)

    p0 = {
      x: 0,
      y: 0
    }
    p1 = {
      x: p1x,
      y: p1y
    }
    p2 = {
      x: p2x,
      y: p2y
    }
    p3 = {
      x: 1,
      y: 1
    }

    x = p0.x * (b0 * d) + p1.x * (b1 * d) + p2.x * (b2 * d) + p3.x * (b3 * d);
    y = p0.y * (b0 * d) + p1.y * (b1 * d) + p2.y * (b2 * d) + p3.y * (b3 * d);

    x: x;
    y: y;

  }
}

cubicbezier(4,0.3,0,0,1);

animate(a) {

  @keyframes {a.name} {

     for type, i in a.animations {

      $p = a.animations[type].property[0];
      $duration = a.animations[type].duration;
      $delay = a.animations[type].delay;
      $accuracy = a.animations[type].accuracy;
      $from = a.animations[type].from;
      $to = a.animations[type].to;
      $total = $duration + $delay;

      $per-delay = $delay / a.total-duration * 100%;
      $per-duration = $duration / a.total-duration * 100%;

      if ($p == transform) {
        $transform-type = a.animations[type].property[1];
        $transform-type-option = a.animations[type].property[2];
        $from = $transform-type + $transform-type-option + "(" + $from + ")";
        $to = $transform-type + $transform-type-option + "(" + $to + ")";
      }

      // Start all animations
      if ($delay > 0) {
        {$per-delay} {
          $p: $from;
        }
      } else {
        0% {
          $p: $from;
        }
      }

      // Animations' keyframes
      if (a.animations[type].curves) {
        for i in ($accuracy)..1 {
          // Return 4 sets of coordinates between 0 and 1
          // so, 20%, 40%, 60% and 80%
          t = i * (1 / ($accuracy + 1));
          d = 1

          b0 = t * t * t
          b1 = 3 * t * t * (1 - t)
          b2 = 3 * t * (1 - t) * (1 - t)
          b3 = (1 - t) * (1 - t) * (1 - t)

          p0 = {
            x: 0,
            y: 0
          }
          p1 = {
            x: a.animations[type].curves.p1x,
            y: a.animations[type].curves.p1y
          }
          p2 = {
            x: a.animations[type].curves.p2x,
            y: a.animations[type].curves.p2y
          }
          p3 = {
            x: 1,
            y: 1
          }

          x = p0.x * (b0 * d) + p1.x * (b1 * d) + p2.x * (b2 * d) + p3.x * (b3 * d);
          y = p0.y * (b0 * d) + p1.y * (b1 * d) + p2.y * (b2 * d) + p3.y * (b3 * d);

          {($per-delay) + (x * $per-duration)} {

            if ($p == transform) {

              $to2 = a.animations[type].to;
              $y = y;
              $new-pos = $to2 * $y;
              $to = $transform-type + $transform-type-option + "(" + $new-pos + ")";

              $p: $to;
            } else {
              $p: y * $to;
            }

          }

        }
      }


      // End all animations
      {$total / a.total-duration * 100%} {
        $p: $to;
      }

      // Preserve end state of any animations to 100%
      if ((a.animations[type].duration + $delay) < a.total-duration) {
        100% {
          $p: $to;
        }
      }

    }

  }

  animation: unquote(a.name + " " + a.total-duration + "s " + a.iteration + " " + a.curves);

}







/** Example
*/



$block-animation = {
  name: block-move,
  total-duration: 2,
  iteration: infinite,
  curves: linear,
  animations: {
    move: {
      property: transform translate Y,
      from: 0px,
      to: 200px,
      duration: 1.5,
      delay: 0,
      curves: {
        p1x: 0.3,
        p1y: 0,
        p2x: 0,
        p2y: 1
      },
      accuracy: 10
    },
    fade: {
      property: opacity,
      from: 1,
      to: 0,
      duration: 0.5,
      delay: 1.5,
      curves: {
        p1x: 0,
        p1y: 0.5,
        p2x: 0.5,
        p2y: 1
      },
      accuracy: 3
    }
  }
}


.block {
  animate($block-animation);
  width: 40px;
  height: @width;
  background: #000;
}
