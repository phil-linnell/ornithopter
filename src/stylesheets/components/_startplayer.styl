// TODO: Move this to JSON
playerColour = {
  yellow: #e7e00f,
  red: #e71f0f,
  white: white,
  blue: #1128d4,
  green: #268b13,
  black: black,
  pink: #de77cc,
  orange: #e9980c,
  purple: #890ce9
}


amount = 9;
rows = 3;
cols = 3;


// Width of the main area
canvas = 210px;

// Starting size of player colour
player = 40px;

// Size of container to which 'player' resides
item = canvas / rows;

// If using 'circle' layout and cDiam = canvas then this
// is the left offset needed to centre everything
offset = item;


duration-position-set = .2s


// Core

.startplayer {

  &, ul {
    width: canvas;
    height: canvas;
  }

  ul {
    position: relative;
    // color: palette(colour, yellow);
  }

  li {
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;
    width: item;
    height: @width;
    cursor: pointer;
    transition: all duration-position-set ease-in-out;


    // Default positions

    // This is the old position order
    // Arranged by grid:
    // 1 2 3
    // 4 5 6
    // 7 8 9

    // for row in 1..rows {
    //   for col in 1..cols {
    //     index = ((col - 1) * 3) + row;
    //     &:nth-child({i}) {
    //       left: row * item - offset;
    //       top: col * item - offset;
    //     }
    //   }
    // }

    // Order or player items positions to emulate a
    // circular pattern so items are close to their
    // positions when in the circle mode. nth-child
    // order is:
    // 1 2 3
    // 8 9 4
    // 7 6 5
    // Refactor into a loop somehow???

    &:nth-child(1) {
      left: 1* item - offset;
      top: 1 * item - offset;
    }
    &:nth-child(2) {
      left: 2 * item - offset;
      top: 1 * item - offset;
    }
    &:nth-child(3) {
      left: 3 * item - offset;
      top: 1 * item - offset;
    }
    &:nth-child(8) {
      left: 1 * item - offset;
      top: 2 * item - offset;
    }
    &:nth-child(9) {
      left: 2 * item - offset;
      top: 2 * item - offset;
    }
    &:nth-child(4) {
      left: 3 * item - offset;
      top: 2 * item - offset;
    }
    &:nth-child(7) {
      left: 1 * item - offset;
      top: 3 * item - offset;
    }
    &:nth-child(6) {
      left: 2 * item - offset;
      top: 3 * item - offset;
    }
    &:nth-child(5) {
      left: 3 * item - offset;
      top: 3 * item - offset;
    }


  }




  // States and colours

  @keyframes pop {
    80% {
      transform: scale(1.6);
    }
    100% {
      transform: scale(1.4);
    }
  }

  li {
    opacity: .3;

    for colour, value in playerColour {
      &.{colour} div {
        background-color: value;
      }
    }

    &[aria-selected="true"] {
      opacity: 1;
      transition: opacity .2s ease-in-out;
      animation: pop .1s linear 1;
      animation-fill-mode: forwards;
    }

    div {
      width: player;
      height: @width;
      border-radius: player * .5;
    }
  }






  // Animate

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  @keyframes disappear {
    0% {
      transform: scale(1);
    }
    45% {
      transform: scale(0.5);
    }
    90% {
      transform: scale(1);
    }
    100% {
      transform: scale(0);
    }
  }

  @keyframes disappearPlayer {
    100% {
      transform: scale(0);
    }
  }

  .players[class*="animate-"] {
    animation: spin .4s linear infinite;
    ul {
      transition: transform .5s linear;
      animation: disappear 3s linear 1;
      li {
        transition: all .32s ease-out;
        animation: disappearPlayer .5s linear 1 2.5s;
      }
    }

    &.stopped {
      animation: none;
      ul {
        animation: none;
        transform: scale(.8) !important;
      }
      li:not(.winner) {
        opacity: 0;
        transition: none;
      }

      @keyframes result {
        0% {
          transform: scale(0);
        }
        70% {
          transform: scale(6);
        }
        100% {
          transform: scale(5);
        }
      }

      .winner {
        top: 50% !important;
        left: 50% !important;
        margin-top: - item * 0.5;
        margin-left: - item * 0.5;
        transition: none;
        transform: scale(5);
        animation: result .32s 1 linear forwards;
      }
    }
  }

  // Position in a circle path
  for i in 1..amount {
    .players.animate-{i} {
      cDiam = canvas - ((amount - i) * 24px);
      cRad  = - cDiam * 0.5; // the negative value here means calculations start top left rather than bottom right
      offset = (canvas - cDiam) / 2;
      cAngle = 360deg / i;
      for i in 1..i {
        li[aria-selected="true"]:nth-child({i}) {
          left: offset + cRad * cos(cAngle * i) - (item * 0.5) - cRad;
          top: offset + cRad * sin(cAngle * i) - (item * 0.5) - cRad;
        }
      }
    }
  }



}


/**
 * NOTES
 *
 *
 *
 *
 *
 *
 */



 // Layout

 .startplayer {
   width: 320px;
   height: 100%;
   margin: 0 auto;
   display: flex;
   flex-direction: column;
   align-items: center;
   justify-content: center;

   h1 {
     position: relative;
     z-index: 10;
     margin-bottom: 50px;
   }
   .buttons {
     margin-top: 50px;
     height: 44px;
   }
   button {
     text-transform: uppercase;
     background: rgba(255,255,255,0.1);
     color: white;
     padding: 0 25px;
     height: 44px;
     border-radius: 3px;
     line-height: @height;
     letter-spacing: 2px;
     color: rgba(white, 0.6);
     transition: opacity .2s ease-in-out;
     position: relative;
     z-index: 10;

     &:active {
       background: rgba(255,255,255,0.25);
     }
     &.hidden {
       display: none;
     }
   }
 }
