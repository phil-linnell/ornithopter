playerColour = {
  yellow: #e7e00f,
  red: #e71f0f,
  white: white,
  blue: #1128d4,
  green: #268b13,
  black: black,
  pink: #de77cc,
  orange: #e9980c,
  purple: #890ce9
}


amount = 9;
rows = 3;
cols = 3;


// Width of the main area
canvas = 210px;

// Starting size of player colour
player = 40px;

// Size of container to which 'player' resides
item = canvas / rows;

// If using 'circle' layout and cDiam = canvas then this
// is the left offset needed to centre everything
offset = item;


duration-position-set = .2s


// Core

.startplayer {

  &, ul {
    width: canvas;
    height: canvas;
  }

  ul {
    position: relative;
  }

  li {
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;
    width: item;
    height: @width;
    transition: all duration-position-set ease-in-out;


    // Default positions

    // This is the old position order
    // Arranged by grid:
    // 1 2 3
    // 4 5 6
    // 7 8 9

    // for row in 1..rows {
    //   for col in 1..cols {
    //     index = ((col - 1) * 3) + row;
    //     &:nth-child({i}) {
    //       left: row * item - offset;
    //       top: col * item - offset;
    //     }
    //   }
    // }

    // Order or player items positions to emulate a
    // circular pattern so items are close to their
    // positions when in the circle mode. nth-child
    // order is:
    // 1 2 3
    // 8 9 4
    // 7 6 5
    // Refactor into a loop??

    &:nth-child(1) {
      left: 1* item - offset;
      top: 1 * item - offset;
    }
    &:nth-child(2) {
      left: 2 * item - offset;
      top: 1 * item - offset;
    }
    &:nth-child(3) {
      left: 3 * item - offset;
      top: 1 * item - offset;
    }
    &:nth-child(8) {
      left: 1 * item - offset;
      top: 2 * item - offset;
    }
    &:nth-child(9) {
      left: 2 * item - offset;
      top: 2 * item - offset;
    }
    &:nth-child(4) {
      left: 3 * item - offset;
      top: 2 * item - offset;
    }
    &:nth-child(7) {
      left: 1 * item - offset;
      top: 3 * item - offset;
    }
    &:nth-child(6) {
      left: 2 * item - offset;
      top: 3 * item - offset;
    }
    &:nth-child(5) {
      left: 3 * item - offset;
      top: 3 * item - offset;
    }


  }




  // States and colours

  @keyframes pop {
    80% {
      transform: scale(1.6);
    }
    100% {
      transform: scale(1.4);
    }
  }

  li {
    opacity: .3;

    for colour, value in playerColour {
      &.{colour} div {
        background-color: value;
      }
    }

    &[aria-selected="true"] {
      opacity: 1;
      transition: opacity .2s ease-in-out;
      animation: pop .1s linear 1;
      animation-fill-mode: forwards;
    }

    div {
      width: player;
      height: @width;
      border-radius: player * .5;
    }
  }






  // Animate

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  @keyframes disappear {
    0% {
      transform: scale(.8);
    }
    60% {
      transform: scale(1);
    }
    100% {
      transform: scale(0);
    }
  }

  @keyframes disappearPlayer {
    100% {
      transform: scale(0);
    }
  }

  @keyframes change {
    0% {
      transform: scale(1);
    }
    50% {
      transform: scale(0);
    }
    100% {
      transform: scale(0.7);
    }
  }

  .players[class*="animate-"] {
    animation: spin .4s linear infinite;
    ul {
      transform: scale(.8);
      transition: transform 3s linear;
      // animation: change .32s linear 1;
      animation: disappear .5s linear 1 2s;
      animation-fill-mode: forwards;
      li {
        transition: all .32s ease-out;
        animation: disappearPlayer .5s linear 1 2s;
        animation-fill-mode: forwards;
      }
    }
  }

  for i in 1..amount {
    .players.animate-{i} {
      cDiam = canvas - ((amount - i) * 25px);
      cRad  = - cDiam * 0.5; // the negative value here means calculations start top left rather than bottom right
      offset = (canvas - cDiam) / 2;
      cAngle = 360deg / i;
      for i in 1..i {
        li[aria-selected="true"]:nth-child({i}) {
          left: offset + cRad * cos(cAngle * i) - (item * 0.5) - cRad;
          top: offset + cRad * sin(cAngle * i) - (item * 0.5) - cRad;
        }
      }
    }
  }


}


/**
 * NOTES
 *
 *
 *
 *
 *
 *
 */



 // Layout

 .startplayer {
   width: 320px;
   height: 100%;
   margin: 0 auto;
   display: flex;
   flex-direction: column;
   align-items: center;
   justify-content: center;

   h1 {
     position: relative;
     z-index: 10;
     margin-bottom: 50px;
   }
   button {
     background: rgba(255,255,255,0.1);
     color: white;
     padding: 0 25px;
     height: 44px;
     border-radius: 3px;
     line-height: @height;
     margin-top: 50px;
     letter-spacing: 2px;
     color: rgba(white, 0.6);
     transition: opacity .2s ease-in-out;
     position: relative;
     z-index: 10;

     &:active {
       background: rgba(255,255,255,0.25);
     }
   }
 }
